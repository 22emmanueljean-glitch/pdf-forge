<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>PDF Forge — Pro Clone & Smooth Drag</title>
<link rel="preconnect" href="https://cdnjs.cloudflare.com">
<style>
  :root{--bg:#0f1115;--panel:#151821;--card:#1a1f2b;--muted:#9aa3b2;--accent:#7aa2ff;--ok:#3ecf8e;--err:#ff6b6b;}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:#e7eaf0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;user-select:none}
  .wrap{display:grid;grid-template-columns:380px 1fr;gap:16px;height:100vh}
  @media (max-width:980px){.wrap{grid-template-columns:1fr;height:auto}}
  .left{padding:16px;overflow:auto;background:#151821;border-right:1px solid #1f2330}
  .right{padding:0 0 16px 0;overflow:auto;background:#0b0d13}
  h1{font-size:18px;margin:6px 0 10px}
  .card{background:#1a1f2b;border:1px solid #22283a;border-radius:12px;padding:12px;margin:10px 0}
  label{font-size:12px;color:#9aa3b2}
  input,textarea,select,button{width:100%;margin-top:6px}
  input,textarea,select{background:#121620;border:1px solid #2a3246;color:#e7eaf0;border-radius:10px;padding:10px}
  textarea{min-height:120px;font-family:ui-monospace,Menlo,Consolas,monospace;resize:vertical;user-select:text}
  button{background:#7aa2ff;border:0;border-radius:10px;padding:12px;font-weight:700;color:#0b0d13;cursor:pointer}
  button.secondary{background:#28304a;color:#e7eaf0}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .status{margin-top:8px;font-size:12px;color:#9aa3b2}
  .status.ok{color:#3ecf8e} .status.err{color:#ff6b6b}
  .pill{display:inline-block;padding:4px 8px;border-radius:999px;background:#22283a;color:#c7d0e0;font-size:12px;margin-right:6px}
  .toolbar{position:sticky;top:0;z-index:2;display:flex;gap:8px;align-items:center;padding:12px;border-bottom:1px solid #1a1f2b;background:#0b0d13}
  .stage{display:flex;justify-content:center}
  .pageWrap{position:relative;display:inline-block;margin:12px auto;background:#0b0d13;border:1px solid #1a1f2b;border-radius:6px;touch-action:none}
  canvas{display:block;touch-action:none}
  .overlay{position:absolute;inset:0;pointer-events:none;touch-action:none}

  /* blocks: outline only so real color shows */
  .block{position:absolute;min-width:80px;min-height:30px;padding:6px 8px;border-radius:6px;pointer-events:auto;cursor:grab;white-space:pre-wrap;line-height:1.35;background:transparent;border:1px dashed #7aa2ff;touch-action:none;will-change:transform}
  .block.dragging{cursor:grabbing}
  .block.selected{border:2px solid var(--accent);z-index:10}
  .handle{position:absolute;right:-8px;bottom:-8px;width:14px;height:14px;border:2px solid #7aa2ff;border-radius:3px;background:#111523;cursor:nwse-resize;touch-action:none}
  .close{position:absolute;top:-9px;left:-9px;width:18px;height:18px;border-radius:50%;background:#ff6b6b;color:#0b0d13;font-size:12px;display:flex;align-items:center;justify-content:center;cursor:pointer;border:1px solid #ff9a9a}
  .close.hidden{display:none}
  body.noguides .block{border-color:transparent}
  .coords{font-size:12px;color:#9aa3b2;margin-left:auto}
  .tinyrow{display:flex;gap:6px;align-items:center;flex-wrap:wrap;margin-top:8px}
  .tinyrow label{display:flex;align-items:center;gap:6px}
</style>
</head>
<body>
<div class="wrap">
  <div class="left">
    <h1>PDF Forge — Pro</h1>

    <div class="card">
      <label>Upload PDF</label>
      <input type="file" id="file" accept="application/pdf"/>
      <div class="row" style="margin-top:10px">
        <button id="load">Load Preview</button>
        <button id="reset" class="secondary">Clear</button>
      </div>
      <div class="status" id="stat">No file loaded.</div>
    </div>

    <div class="card" id="tools" style="display:none">
      <div class="row">
        <div>
          <label>Page</label>
          <select id="pageSelect"></select>
        </div>
        <div>
          <label>Zoom</label>
          <input type="range" id="zoom" min="50" max="200" value="110">
        </div>
      </div>

      <div class="tinyrow">
        <label><input type="checkbox" id="toggleGuides" checked> Show outlines</label>
        <button id="eyedrop" class="secondary" style="padding:8px 10px">Eyedrop (style+color)</button>
        <button id="cloneSection" class="secondary" style="padding:8px 10px">Clone Section (auto)</button>
        <span class="pill" id="picked">picked: —</span>
      </div>

      <div class="row">
        <div>
          <label>Font</label>
          <select id="font">
            <option>Times-Roman</option>
            <option>Times-Bold</option>
            <option>Times-Italic</option>
            <option>Times-BoldItalic</option>
            <option>Helvetica</option>
            <option>Helvetica-Bold</option>
            <option>Helvetica-Oblique</option>
            <option>Helvetica-BoldOblique</option>
            <option>Courier</option>
            <option>Courier-Bold</option>
            <option>Courier-Oblique</option>
            <option>Courier-BoldOblique</option>
          </select>
        </div>
        <div>
          <label>Size (pt)</label>
          <input id="size" type="number" step="0.5" value="11">
        </div>
      </div>

      <div class="row">
        <div>
          <label>Color</label>
          <input id="color" type="color" value="#000000">
          <div class="tinyrow">
            <button id="quickRed" class="secondary" style="padding:6px 8px">Red</button>
            <button id="quickBlue" class="secondary" style="padding:6px 8px">Blue</button>
            <button id="quickBody" class="secondary" style="padding:6px 8px">Body</button>
          </div>
        </div>
        <div>
          <label>Width (pt)</label>
          <input id="width" type="number" value="460">
        </div>
      </div>

      <div class="row">
        <div>
          <label>Line Height (pt)</label>
          <input id="lineHeight" type="number" step="0.1" value="15">
        </div>
        <div>
          <label>Faux Bold (0–3)</label>
          <input id="fauxBold" type="number" min="0" max="3" value="0">
        </div>
      </div>

      <div class="row">
        <div>
          <label>Italic Skew (°)</label>
          <input id="skewDeg" type="number" step="1" value="0">
        </div>
        <div>
          <label>Tracking (pt/char)</label>
          <input id="tracking" type="number" step="0.05" value="0">
        </div>
      </div>

      <label>Text</label>
      <textarea id="text" placeholder="Type your text to insert or edit…"></textarea>

      <div class="row">
        <button id="addText">Add Text (click preview to place)</button>
        <button id="addLine" class="secondary">Add Line (click to place)</button>
      </div>

      <div class="row" style="margin-top:6px">
        <div>
          <label>Line Width (pt)</label>
          <input id="lineWidth" type="number" value="460">
        </div>
        <div>
          <label>Line Thickness (pt)</label>
          <input id="lineThick" type="number" value="2">
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="apply" class="secondary">Generate v4</button>
        <button id="clearBlocks" class="secondary">Remove All</button>
      </div>

      <div class="status" id="queued">0 items queued</div>
    </div>
  </div>

  <div class="right">
    <div class="toolbar">
      <span class="pill" id="meta">Page — | scale 1.00</span>
      <button id="prev" class="secondary">◀</button>
      <button id="next" class="secondary">▶</button>
      <span class="coords" id="coords">x: —  y: —</span>
    </div>
    <div class="stage">
      <div class="pageWrap" id="pageWrap" style="display:none">
        <canvas id="cv"></canvas>
        <div class="overlay" id="overlay"></div>
      </div>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script>
const API_EDIT="/api/edit";

// ===== Helpers =====
async function fileToBase64(file){
  return new Promise((resolve,reject)=>{
    const fr=new FileReader();
    fr.onload=()=>{const s=String(fr.result||""); resolve(s.includes(",")?s.split(",")[1]:s);};
    fr.onerror=reject;
    fr.readAsDataURL(file);
  });
}
function hexToRgb01(hex){
  const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  if(!m) return [0,0,0];
  return [parseInt(m[1],16)/255, parseInt(m[2],16)/255, parseInt(m[3],16)/255];
}
const $=id=>document.getElementById(id);
const setStat=(t,cls="")=>{const el=$('stat'); el.textContent=t; el.className="status "+cls;};
const setMeta=()=>$('meta').textContent=`Page ${pageNum} | scale ${scale.toFixed(2)}`;
const setQueued=()=>$('queued').textContent=items.length+" items queued";

// ===== State =====
let pdfDoc=null, pageNum=1, pageCount=1, scale=1.10, ptPerPx=1;
let fileB64=null, lastClickPt=null;
let items=[]; // {id,type:'text'|'line',page,x,y,width,text,font,size,colorHex,thick,lineHeight,fauxBold,skewDeg,tracking}
let selectedId=null;

const pdfjsLib=window['pdfjs-dist/build/pdf'];
pdfjsLib.GlobalWorkerOptions.workerSrc='https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

// ===== Load Preview =====
$('load').onclick=async()=>{
  try{
    const f=$('file').files[0]; if(!f){setStat("Choose a PDF."); return;}
    fileB64=await fileToBase64(f);
    const buf=await f.arrayBuffer();
    pdfDoc=await pdfjsLib.getDocument({data:buf}).promise;
    pageCount=pdfDoc.numPages; pageNum=1;
    $('tools').style.display='';
    const sel=$('pageSelect'); sel.innerHTML="";
    for(let i=1;i<=pageCount;i++){const o=document.createElement('option'); o.value=String(i); o.textContent=String(i); sel.appendChild(o);}
    sel.value="1";
    await renderPage();
    drawOverlay();
    setStat(`Loaded ${pageCount} page(s).`,"ok");
  }catch(e){ setStat("Error: "+e.message,"err"); }
};
$('reset').onclick=()=>{
  pdfDoc=null; fileB64=null; items=[]; selectedId=null; $('tools').style.display='none';
  $('cv').getContext('2d').clearRect(0,0,$('cv').width,$('cv').height);
  $('overlay').innerHTML=""; $('pageWrap').style.display='none';
  setQueued(); setStat("Cleared.");
};

// ===== Navigation / Zoom =====
$('prev').onclick=async()=>{if(!pdfDoc)return; pageNum=Math.max(1,pageNum-1); $('pageSelect').value=String(pageNum); await renderPage(); drawOverlay();};
$('next').onclick=async()=>{if(!pdfDoc)return; pageNum=Math.min(pageCount,pageNum+1); $('pageSelect').value=String(pageNum); await renderPage(); drawOverlay();};
$('zoom').oninput=async e=>{if(!pdfDoc)return; scale=Number(e.target.value)/100; await renderPage(); drawOverlay();};
$('pageSelect').onchange=async e=>{pageNum=Number(e.target.value)||1; await renderPage(); drawOverlay();};

async function renderPage(){
  const page=await pdfDoc.getPage(pageNum);
  const viewport=page.getViewport({scale});
  const cv=$('cv'), ctx=cv.getContext('2d');
  cv.width=viewport.width; cv.height=viewport.height;
  const baseViewport=page.getViewport({scale:1});
  ptPerPx=baseViewport.width/viewport.width;
  await page.render({canvasContext:ctx, viewport}).promise;
  $('pageWrap').style.display='';
  setMeta();
  cv.onpointermove=(e)=>{
    const r=cv.getBoundingClientRect();
    const x=Math.round((e.clientX-r.left)*ptPerPx);
    const y=Math.round((e.clientY-r.top)*ptPerPx);
    $('coords').textContent=`x: ${x}  y: ${y}`;
  };
}

// ===== Guides toggle =====
$('toggleGuides').onchange=(e)=>{
  if(e.target.checked) document.body.classList.remove('noguides');
  else document.body.classList.add('noguides');
};

// ===== Eyedropper & Section Clone =====
let eyedropMode=false, cloneSectionMode=false;
$('eyedrop').onclick=()=>{
  eyedropMode=!eyedropMode; cloneSectionMode=false;
  $('eyedrop').textContent = eyedropMode ? "Eyedrop (ON)" : "Eyedrop (style+color)";
  $('cloneSection').textContent = "Clone Section (auto)";
  setStat(eyedropMode ? "Click near text to pick style & color." : "Eyedrop off.","ok");
};
$('cloneSection').onclick=()=>{
  cloneSectionMode=!cloneSectionMode; eyedropMode=false;
  $('cloneSection').textContent = cloneSectionMode ? "Clone Section (ON)" : "Clone Section (auto)";
  $('eyedrop').textContent = "Eyedrop (style+color)";
  setStat(cloneSectionMode ? "Click somewhere inside a section (heading+para) to clone it." : "Section clone off.","ok");
};

// Font mapping with weight/italic heuristics
function guessFontFromName(name){
  const fname = (name||'').toString();
  const isHelv = /helv/i.test(fname);
  const isCour = /cour/i.test(fname);
  const isTimes= /times|newroman|tnr|minion|garamond|serif/i.test(fname) || (!isHelv && !isCour);
  const isBold = /bold|bd|semibold|demi|medium/i.test(fname);
  const isItal = /ital|oblique|it|obl/i.test(fname);
  if(isHelv) return isBold && isItal ? 'Helvetica-BoldOblique' : isBold ? 'Helvetica-Bold' : isItal ? 'Helvetica-Oblique' : 'Helvetica';
  if(isCour) return isBold && isItal ? 'Courier-BoldOblique'  : isBold ? 'Courier-Bold'  : isItal ? 'Courier-Oblique'  : 'Courier';
  return isBold && isItal ? 'Times-BoldItalic' : isBold ? 'Times-Bold' : isItal ? 'Times-Italic' : 'Times-Roman';
}

// nearest text span
async function nearestTextInfoAt(pt){
  const page=await pdfDoc.getPage(pageNum);
  const tc=await page.getTextContent();
  let best=null, bestD=1e15;
  for(const it of tc.items){
    const a=it.transform[0], d=it.transform[3], ex=it.transform[4], ey=it.transform[5];
    const w=it.width, size=Math.max(Math.abs(a),Math.abs(d));
    const cx=ex + (w/2), cy=ey;
    const dx=cx-pt.x, dy=cy-pt.y; const dd=dx*dx+dy*dy;
    if(dd<bestD){
      bestD=dd;
      best={ text:it.str, size, font:guessFontFromName(it.fontName), x:ex, y:ey, width:w, fontName:it.fontName };
    }
  }
  return best;
}

// group text into lines/paragraphs around a click (simple baseline grouping)
async function sectionAround(pt){
  const page=await pdfDoc.getPage(pageNum);
  const tc=await page.getTextContent();
  // Normalize items: baseline y, size, font
  const its = tc.items.map(it=>{
    const a=it.transform[0], d=it.transform[3], ex=it.transform[4], ey=it.transform[5];
    return { str:it.str, x:ex, y:ey, w:it.width, size:Math.max(Math.abs(a),Math.abs(d)), fontName:it.fontName };
  }).sort((A,B)=>B.y - A.y || A.x - B.x);

  // find clicked item
  let idx=0, bestD=1e15;
  for(let i=0;i<its.length;i++){
    const cx=its[i].x + (its[i].w/2), cy=its[i].y;
    const dx=cx-pt.x, dy=cy-pt.y; const dd=dx*dx+dy*dy;
    if(dd<bestD){bestD=dd; idx=i;}
  }
  const center=its[idx]; if(!center) return [];

  // baseline tolerance
  const tol = Math.max(1.5, center.size*0.4);

  // collect items within a vertical window around the center to form a section (up to ~10 lines)
  const windowTop = center.y + center.size*6;
  const windowBot = center.y - center.size*20;
  const within = its.filter(s=>s.y<=windowTop && s.y>=windowBot);

  // group by baselines
  const lines=[];
  within.forEach(s=>{
    let ln = lines.find(L=>Math.abs(L.y - s.y) <= tol);
    if(!ln){ ln={y:s.y, size:s.size, font:guessFontFromName(s.fontName), rawFont:s.fontName, segs:[], xMin:s.x, xMax:s.x+s.w}; lines.push(ln); }
    ln.segs.push(s);
    ln.xMin=Math.min(ln.xMin,s.x); ln.xMax=Math.max(ln.xMax,s.x+s.w);
  });
  lines.sort((a,b)=>b.y - a.y);

  // split into blocks when font/size/color likely changes (we don't have color here; UI will sample)
  const blocks=[]; let cur=null;
  for(const L of lines){
    if(!cur || Math.abs(cur.size - L.size) > 0.6 || cur.font !== L.font){
      cur = { lines:[], size:L.size, font:L.font, rawFont:L.rawFont, xMin:L.xMin, xMax:L.xMax, yTop:L.y, lineGap:0 };
      blocks.push(cur);
    }
    cur.lines.push(L);
    cur.xMin=Math.min(cur.xMin,L.xMin); cur.xMax=Math.max(cur.xMax,L.xMax);
  }
  // estimate lineGap per block
  blocks.forEach(b=>{
    const gaps=[];
    for(let i=1;i<b.lines.length;i++) gaps.push(b.lines[i-1].y - b.lines[i].y);
    b.lineGap = gaps.length ? (gaps.reduce((a,c)=>a+c,0)/gaps.length) : b.size*1.35;
  });

  // build block models
  const result = blocks.map(b=>{
    const text = b.lines.map(L=>{
      const sorted=L.segs.sort((a,b)=>a.x-b.x);
      return sorted.map(s=>s.str).join('');
    }).join('\n');
    return {
      type:'text',
      font:b.font,
      size:Math.round(b.size),
      lineHeight: Math.max( b.lineGap, b.size*1.2 ),
      width: Math.round((b.xMax - b.xMin)+4),
      x: Math.round(b.xMin),
      y: Math.round(b.lines[0].y),
      text,
      // faux defaults will be refined by color sampler when placed
      fauxBold: /bold|semi|demi|medium/i.test(b.rawFont) ? 1 : 0,
      skewDeg: /ital|obl/i.test(b.rawFont) ? 12 : 0,
      tracking: 0
    };
  });

  return result;
}

// adaptive, median-of-ink color sampler
function sampleColorMedian(pxX, pxY){
  const cv=$('cv'), ctx=cv.getContext('2d');
  let radius=3, best='#000000';
  const toHex=v=>Math.round(v).toString(16).padStart(2,'0');
  function med(arr){const a=arr.slice().sort((x,y)=>x-y), n=a.length; return n? a[Math.floor(n/2)] : 0;}
  while(radius<=10){
    const x0=Math.max(0, Math.round(pxX)-radius);
    const y0=Math.max(0, Math.round(pxY)-radius);
    const w=Math.min(radius*2+1, cv.width-x0);
    const h=Math.min(radius*2+1, cv.height-y0);
    const data=ctx.getImageData(x0,y0,w,h).data;
    const Rs=[],Gs=[],Bs=[];
    for(let i=0;i<data.length;i+=4){
      const r=data[i], g=data[i+1], b=data[i+2];
      const lum=0.2126*r+0.7152*g+0.0722*b;
      if(lum>235) continue; // ignore paper
      Rs.push(r); Gs.push(g); Bs.push(b);
    }
    if(Rs.length){
      best = '#'+toHex(med(Rs))+toHex(med(Gs))+toHex(med(Bs));
      break;
    }
    radius+=2;
  }
  return best;
}

// canvas click handler
$('cv').addEventListener('pointerdown', async (e)=>{
  e.preventDefault();
  const r=$('cv').getBoundingClientRect();
  const pxX = e.clientX - r.left;
  const pxY = e.clientY - r.top;
  const xPt=Math.round(pxX*ptPerPx);
  const yPt=Math.round(pxY*ptPerPx);

  if(eyedropMode){
    const info = await nearestTextInfoAt({x:xPt,y:yPt});
    if(info){
      $('size').value = Math.max(6, Math.round(info.size));
      $('font').value = info.font;
      $('color').value = sampleColorMedian(pxX, pxY);
      $('picked').textContent = `picked: ${info.font}, ${$('size').value}pt, ${$('color').value}`;
      setStat("Style picked.","ok");
    } else setStat("No text near click.","err");
    eyedropMode=false; $('eyedrop').textContent="Eyedrop (style+color)";
    return;
  }
  if(cloneSectionMode){
    const blocks = await sectionAround({x:xPt,y:yPt});
    if(!blocks.length){ setStat("Couldn’t detect a section here.","err"); return; }
    // place each block at click X, stacking with detected leading
    let yCursor = yPt;
    blocks.forEach(b=>{
      const id = crypto.randomUUID?crypto.randomUUID():String(Date.now()+Math.random());
      const hex = sampleColorMedian(pxX, pxY);
      const it = {
        id, type:'text', page:pageNum,
        x:xPt, y:yCursor,
        width:b.width, text:b.text,
        font:b.font, size:b.size, colorHex:hex,
        lineHeight: Math.round(b.lineHeight),
        fauxBold: b.fauxBold||0, skewDeg: b.skewDeg||0, tracking: b.tracking||0
      };
      items.push(it);
      yCursor += (b.lineHeight * (b.text.split('\n').length + 1));
    });
    setQueued(); setSelected(blocks.length ? items[items.length-1].id : null); drawOverlay();
    setStat(`Cloned ${blocks.length} block(s). Edit or move freely.`, "ok");
    cloneSectionMode=false; $('cloneSection').textContent="Clone Section (auto)";
    return;
  }

  // default placement
  lastClickPt={x:xPt,y:yPt};
  setStat(`Placement set at (${xPt}, ${yPt}).`,"ok");
});

// ===== selection & sidebar sync =====
function setSelected(id){
  selectedId = id;
  const it = items.find(x=>x.id===selectedId);
  if(!it){ $('text').value=""; drawOverlay(); return; }
  if(it.type==='text'){
    $('text').value = it.text || "";
    $('font').value = it.font || 'Times-Roman';
    $('size').value = it.size || 11;
    $('color').value = it.colorHex || '#000000';
    $('width').value = it.width || 460;
    $('lineHeight').value = it.lineHeight || Math.round((it.size||11)*1.35);
    $('fauxBold').value = it.fauxBold || 0;
    $('skewDeg').value = it.skewDeg || 0;
    $('tracking').value = it.tracking || 0;
  } else {
    $('text').value = "";
    $('color').value = it.colorHex || '#000000';
    $('lineWidth').value = it.width || 460;
    $('lineThick').value = it.thick || 2;
  }
  drawOverlay();
}
function updateSelectedFromSidebar(){
  const it = items.find(x=>x.id===selectedId);
  if(!it) return;
  if(it.type==='text'){
    it.text = $('text').value || "";
    it.font = $('font').value || "Times-Roman";
    it.size = parseFloat($('size').value)||11;
    it.colorHex = $('color').value || "#000000";
    it.width = parseFloat($('width').value)||460;
    it.lineHeight = parseFloat($('lineHeight').value)||Math.round(it.size*1.35);
    it.fauxBold = parseInt($('fauxBold').value)||0;
    it.skewDeg = parseFloat($('skewDeg').value)||0;
    it.tracking = parseFloat($('tracking').value)||0;
  } else {
    it.colorHex = $('color').value || it.colorHex || "#000000";
    it.width = parseFloat($('lineWidth').value)||it.width||460;
    it.thick = parseFloat($('lineThick').value)||it.thick||2;
  }
  drawOverlay();
}
['text','font','size','color','width','lineHeight','fauxBold','skewDeg','tracking','lineWidth','lineThick'].forEach(id=>{
  $(id).addEventListener(id==='text'?'input':'change', updateSelectedFromSidebar);
});

// keyboard delete for selected
window.addEventListener('keydown',(e)=>{
  if(!selectedId) return;
  if(e.key==='Delete' || e.key==='Backspace'){
    items = items.filter(x=>x.id!==selectedId);
    selectedId=null; drawOverlay(); setQueued(); setStat("Deleted selected item.","ok");
    e.preventDefault();
  }
});

// ===== Add Text / Line =====
$('addText').onclick=()=>{
  if(!fileB64){ setStat("Load a PDF first.","err"); return; }
  if(!lastClickPt){ setStat("Click preview to choose a position first.","err"); return; }
  const pg=Number($('pageSelect').value)||pageNum;
  const id=crypto.randomUUID?crypto.randomUUID():String(Date.now()+Math.random());
  const it = {
    id, type:'text', page:pg,
    x:lastClickPt.x, y:lastClickPt.y,
    width: parseFloat($('width').value)||460,
    text: $('text').value||"",
    font: $('font').value||"Times-Roman",
    size: parseFloat($('size').value)||11,
    colorHex: $('color').value||"#000000",
    lineHeight: parseFloat($('lineHeight').value)||Math.round((parseFloat($('size').value)||11)*1.35),
    fauxBold: parseInt($('fauxBold').value)||0,
    skewDeg: parseFloat($('skewDeg').value)||0,
    tracking: parseFloat($('tracking').value)||0
  };
  items.push(it); setQueued(); setSelected(it.id); drawOverlay();
  setStat("Text block added & selected.","ok");
};
$('addLine').onclick=()=>{
  if(!fileB64){ setStat("Load a PDF first.","err"); return; }
  if(!lastClickPt){ setStat("Click preview to choose a position first.","err"); return; }
  const pg=Number($('pageSelect').value)||pageNum;
  const id=crypto.randomUUID?crypto.randomUUID():String(Date.now()+Math.random());
  const it = {
    id, type:'line', page:pg,
    x:lastClickPt.x, y:lastClickPt.y,
    width: parseFloat($('lineWidth').value)||460,
    thick: parseFloat($('lineThick').value)||2,
    colorHex: $('color').value||"#000000"
  };
  items.push(it); setQueued(); setSelected(it.id); drawOverlay();
  setStat("Line added & selected.","ok");
};

// ===== Remove All =====
$('clearBlocks').onclick=()=>{ items=[]; selectedId=null; drawOverlay(); setQueued(); setStat("All items removed.","ok"); };

// ===== Overlay rendering with ultra-smooth drag (translate3d + RAF) =====
function drawOverlay(){
  const ov=$('overlay'); ov.innerHTML="";
  const pageItems=items.filter(it=>it.page===pageNum);

  pageItems.forEach(it=>{
    const div=document.createElement('div');
    div.className='block';
    div.dataset.id = it.id;
    if(it.id===selectedId) div.classList.add('selected');

    const close=document.createElement('div');
    close.className='close' + (it.id===selectedId ? '' : ' hidden');
    close.textContent='×';
    close.title='Delete this';
    close.onclick=(ev)=>{ ev.stopPropagation(); items = items.filter(x=>x.id!==it.id); if(selectedId===it.id) selectedId=null; drawOverlay(); setQueued(); };
    div.appendChild(close);

    const handle=document.createElement('div');
    handle.className='handle';
    div.appendChild(handle);

    // base position via left/top; live-drag via translate
    const baseLeft = it.x/ptPerPx;
    const baseTop  = it.y/ptPerPx;
    div.style.left = baseLeft+'px';
    div.style.top  = baseTop+'px';

    if(it.type==='text'){
      div.style.width=(it.width/ptPerPx)+'px';
      div.style.fontFamily=it.font;
      div.style.fontSize=(it.size/ptPerPx)+'px';
      div.style.color=it.colorHex;
      div.style.lineHeight = (it.lineHeight/ptPerPx);
      div.textContent=it.text;
    } else {
      const pxH=Math.max(1, it.thick/ptPerPx);
      div.style.top=((it.y/ptPerPx)-(pxH/2))+'px';
      div.style.width=(it.width/ptPerPx)+'px';
      div.style.height=pxH+'px';
      div.style.background=it.colorHex;
      div.textContent='';
    }

    // SELECT
    div.addEventListener('pointerdown',ev=>{
      ev.preventDefault();
      if(ev.target!==handle && ev.target!==close) setSelected(it.id);
    }, {passive:false});

    // DRAG with RAF
    div.addEventListener('pointerdown',ev=>{
      if(ev.target===handle || ev.target===close) return;
      ev.preventDefault();
      setSelected(it.id);
      div.classList.add('dragging');

      const startX=ev.clientX, startY=ev.clientY;
      let dx=0, dy=0, anim=false;

      const move=(e)=>{ dx=e.clientX-startX; dy=e.clientY-startY; if(!anim){ anim=true; requestAnimationFrame(tick); } };
      const tick=()=>{ div.style.transform=`translate3d(${dx}px,${dy}px,0)`; anim=false; };
      const up=()=>{
        document.removeEventListener('pointermove',move);
        document.removeEventListener('pointerup',up);
        div.classList.remove('dragging');
        div.style.transform='translate3d(0,0,0)';
        // commit to points
        const newLeft = baseLeft + dx;
        const newTop  = baseTop + dy;
        if(it.type==='text'){
          it.x = Math.round(newLeft*ptPerPx);
          it.y = Math.round(newTop*ptPerPx);
        } else {
          const pxH=Math.max(1, it.thick/ptPerPx);
          it.x = Math.round(newLeft*ptPerPx);
          it.y = Math.round((newTop + pxH/2)*ptPerPx);
        }
        // re-render base to avoid drift
        drawOverlay();
      };
      document.addEventListener('pointermove',move,{passive:false});
      document.addEventListener('pointerup',up,{once:true});
    }, {passive:false});

    // RESIZE width (commit with RAF-like smoothness not needed)
    handle.addEventListener('pointerdown',ev=>{
      ev.stopPropagation(); ev.preventDefault();
      setSelected(it.id);
      const startX=ev.clientX, startW=parseFloat((it.width/ptPerPx).toFixed(2));
      const move=(e)=>{
        const dw=e.clientX-startX;
        const newW=Math.max(20, startW+dw);
        div.style.width=newW+'px';
      };
      const up=()=>{
        document.removeEventListener('pointermove',move);
        document.removeEventListener('pointerup',up);
        it.width=Math.round(parseFloat(div.style.width)*ptPerPx);
        if(it.id===selectedId) $('width').value = it.width;
      };
      document.addEventListener('pointermove',move,{passive:false});
      document.addEventListener('pointerup',up,{once:true});
    });

    ov.appendChild(div);
  });

  ov.style.pointerEvents='none';
  Array.from(ov.children).forEach(c=>c.style.pointerEvents='auto');
}

// ===== Generate v4 =====
$('apply').onclick=async()=>{
  try{
    if(!fileB64){ setStat("Load a PDF first.","err"); return; }
    if(items.length===0){ setStat("No items queued.","err"); return; }
    setStat("Generating…");
    const edits = items.map(it=>{
      const [r,g,b]=hexToRgb01(it.colorHex||'#000000');
      if(it.type==='text'){
        return {
          type:'text', page:it.page, x:it.x, y:it.y, width:it.width,
          text:it.text, font:it.font, size:it.size, color:[r,g,b],
          lineHeight: it.lineHeight || Math.round(it.size*1.35),
          fauxBold: it.fauxBold||0, skewDeg: it.skewDeg||0, tracking: it.tracking||0
        };
      } else {
        return {type:'line', page:it.page, x:it.x, y:it.y, width:it.width, thick:it.thick, color:[r,g,b]};
      }
    });
    const r=await fetch(API_EDIT,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({file:fileB64,edits})});
    if(!r.ok){ const t=await r.text(); throw new Error(t||r.statusText); }
    const { pdf }=await r.json();
    const blob=new Blob([Uint8Array.from(atob(pdf),c=>c.charCodeAt(0))],{type:'application/pdf'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download='Gravitational_Aura_Masterclass_FINAL_CLEAN_v4.pdf'; a.click();
    setStat("Done ✓ File downloaded.","ok");
  }catch(e){ setStat("Error: "+e.message,"err"); }
};

// quick colors update selected immediately
$('quickRed').onclick=()=>{ $('color').value='#c62828'; updateSelectedFromSidebar(); };
$('quickBlue').onclick=()=>{ $('color').value='#1565c0'; updateSelectedFromSidebar(); };
$('quickBody').onclick=()=>{ $('color').value='#000000'; updateSelectedFromSidebar(); };
</script>
</body>
</html>
