<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>PDF Forge — Pro (FINAL)</title>
<link rel="preconnect" href="https://cdnjs.cloudflare.com">
<style>
  :root{
    --bg:#0f1115;--panel:#151821;--card:#1a1f2b;--muted:#9aa3b2;--accent:#7aa2ff;
    --ok:#3ecf8e;--err:#ff6b6b;--border:#1f2330;--ink:#e7eaf0;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;user-select:none}
  .wrap{display:grid;grid-template-columns:380px 1fr;gap:16px;height:100vh}
  @media (max-width:980px){.wrap{grid-template-columns:1fr;height:auto}}
  .left{padding:16px;overflow:auto;background:var(--panel);border-right:1px solid var(--border)}
  .right{padding:0 0 16px 0;overflow:auto;background:#0b0d13}
  h1{font-size:18px;margin:6px 0 10px}
  .card{background:var(--card);border:1px solid #22283a;border-radius:12px;padding:12px;margin:10px 0}
  label{font-size:12px;color:var(--muted)}
  input,textarea,select,button{width:100%;margin-top:6px}
  input,textarea,select{background:#121620;border:1px solid #2a3246;color:var(--ink);border-radius:10px;padding:10px}
  textarea{min-height:120px;font-family:ui-monospace,Menlo,Consolas,monospace;resize:vertical;user-select:text}
  button{background:var(--accent);border:0;border-radius:10px;padding:12px;font-weight:700;color:#0b0d13;cursor:pointer}
  button.secondary{background:#28304a;color:var(--ink)}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .status{margin-top:8px;font-size:12px;color:var(--muted)}
  .status.ok{color:var(--ok)} .status.err{color:var(--err)}
  .pill{display:inline-block;padding:4px 8px;border-radius:999px;background:#22283a;color:#c7d0e0;font-size:12px;margin-right:6px}
  .toolbar{position:sticky;top:0;z-index:2;display:flex;gap:8px;align-items:center;padding:12px;border-bottom:1px solid #1a1f2b;background:#0b0d13}
  .stage{display:flex;justify-content:center}
  .pageWrap{position:relative;display:inline-block;margin:12px auto;background:#0b0d13;border:1px solid #1a1f2b;border-radius:6px;touch-action:none}
  canvas{display:block;touch-action:none}
  .overlay{position:absolute;inset:0;pointer-events:none;touch-action:none}

  /* item blocks (overlay) */
  .block{position:absolute;min-width:80px;min-height:30px;padding:6px 8px;border-radius:6px;pointer-events:auto;cursor:grab;white-space:pre-wrap;line-height:1.35;background:transparent;border:1px dashed var(--accent);touch-action:none;will-change:transform}
  .block.dragging{cursor:grabbing}
  .block.selected{border:2px solid var(--accent);z-index:11}
  .handle{position:absolute;right:-8px;bottom:-8px;width:14px;height:14px;border:2px solid var(--accent);border-radius:3px;background:#111523;cursor:nwse-resize;touch-action:none}
  .close{position:absolute;top:-9px;left:-9px;width:18px;height:18px;border-radius:50%;background:var(--err);color:#0b0d13;font-size:12px;display:flex;align-items:center;justify-content:center;cursor:pointer;border:1px solid #ff9a9a}
  .close.hidden{display:none}
  body.noguides .block{border-color:transparent}

  /* group frame */
  .group{position:absolute;border:2px dashed #3b82f6;border-radius:8px;background:transparent;pointer-events:auto;touch-action:none;will-change:transform}
  .group.selected{border-color:var(--accent);z-index:12}
  .g-handle{position:absolute;width:14px;height:14px;background:#111523;border:2px solid var(--accent);border-radius:3px}
  .g-handle.br{right:-9px;bottom:-9px;cursor:nwse-resize}
  .g-handle.tl{left:-9px;top:-9px;cursor:nwse-resize}
  .g-handle.tr{right:-9px;top:-9px;cursor:nesw-resize}
  .g-handle.bl{left:-9px;bottom:-9px;cursor:nesw-resize}
  .g-close{position:absolute;top:-11px;left:50%;transform:translateX(-50%);width:20px;height:20px;border-radius:50%;background:var(--err);color:#0b0d13;font-size:12px;display:flex;align-items:center;justify-content:center;cursor:pointer;border:1px solid #ff9a9a}

  .coords{font-size:12px;color:var(--muted);margin-left:auto}
  .tinyrow{display:flex;gap:6px;align-items:center;flex-wrap:wrap;margin-top:8px}
  .tinyrow label{display:flex;align-items:center;gap:6px}

  /* marquee */
  .marquee{position:absolute;border:1px solid var(--accent);background:rgba(122,162,255,0.15);pointer-events:none}
</style>
</head>
<body>
<div class="wrap">
  <div class="left">
    <h1>PDF Forge — Pro (FINAL)</h1>
    <div class="card">
      <label>Upload PDF</label>
      <input type="file" id="file" accept="application/pdf"/>
      <div class="row" style="margin-top:10px">
        <button id="load">Load Preview</button>
        <button id="reset" class="secondary">Clear</button>
      </div>
      <div class="status" id="stat">No file loaded.</div>
    </div>

    <div class="card" id="tools" style="display:none">
      <div class="row">
        <div>
          <label>Page</label>
          <select id="pageSelect"></select>
        </div>
        <div>
          <label>Zoom</label>
          <input type="range" id="zoom" min="50" max="260" value="110">
        </div>
      </div>

      <div class="tinyrow">
        <label><input type="checkbox" id="toggleGuides" checked> Show outlines</label>
        <button id="eyedrop" class="secondary" style="padding:8px 10px">Eyedrop</button>
        <button id="areaClone" class="secondary" style="padding:8px 10px">Select Area (Clone)</button>
        <button id="ungroup" class="secondary" style="padding:8px 10px">Ungroup</button>
        <label><input type="checkbox" id="detectRules" checked> Detect rules</label>
        <span class="pill" id="picked">picked: —</span>
      </div>

      <div class="row">
        <div>
          <label>Font</label>
          <select id="font">
            <option>Times-Roman</option>
            <option>Times-Bold</option>
            <option>Times-Italic</option>
            <option>Times-BoldItalic</option>
            <option>Helvetica</option>
            <option>Helvetica-Bold</option>
            <option>Helvetica-Oblique</option>
            <option>Helvetica-BoldOblique</option>
            <option>Courier</option>
            <option>Courier-Bold</option>
            <option>Courier-Oblique</option>
            <option>Courier-BoldOblique</option>
          </select>
        </div>
        <div>
          <label>Size (pt)</label>
          <input id="size" type="number" step="0.5" value="11">
        </div>
      </div>

      <div class="row">
        <div>
          <label>Color</label>
          <input id="color" type="color" value="#000000">
          <div class="tinyrow">
            <button id="quickRed" class="secondary" style="padding:6px 8px">Red</button>
            <button id="quickBlue" class="secondary" style="padding:6px 8px">Blue</button>
            <button id="quickBody" class="secondary" style="padding:6px 8px">Body</button>
          </div>
        </div>
        <div>
          <label>Width (pt)</label>
          <input id="width" type="number" value="460">
        </div>
      </div>

      <div class="row">
        <div>
          <label>Line Height (pt)</label>
          <input id="lineHeight" type="number" step="0.1" value="15">
        </div>
        <div>
          <label>Faux Bold (0–3)</label>
          <input id="fauxBold" type="number" min="0" max="3" value="0">
        </div>
      </div>

      <div class="row">
        <div>
          <label>Italic Skew (°)</label>
          <input id="skewDeg" type="number" step="1" value="0">
        </div>
        <div>
          <label>Tracking (pt/char)</label>
          <input id="tracking" type="number" step="0.05" value="0">
        </div>
      </div>

      <label>Text</label>
      <textarea id="text" placeholder="Type your text to insert or edit…"></textarea>

      <div class="row">
        <button id="addText">Add Text (click preview to place)</button>
        <button id="addLine" class="secondary">Add Line (click to place)</button>
      </div>

      <div class="row" style="margin-top:6px">
        <div>
          <label>Line Width (pt)</label>
          <input id="lineWidth" type="number" value="460">
        </div>
        <div>
          <label>Line Thickness (pt)</label>
          <input id="lineThick" type="number" value="2">
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="apply" class="secondary">Generate PDF</button>
        <button id="clearBlocks" class="secondary">Remove All</button>
      </div>

      <div class="status" id="queued">0 items queued</div>
    </div>
  </div>

  <div class="right">
    <div class="toolbar">
      <span class="pill" id="meta">Page — | scale 1.00</span>
      <button id="prev" class="secondary">◀</button>
      <button id="next" class="secondary">▶</button>
      <span class="coords" id="coords">x: —  y: —</span>
    </div>
    <div class="stage">
      <div class="pageWrap" id="pageWrap" style="display:none">
        <canvas id="cv"></canvas>
        <div class="overlay" id="overlay"></div>
      </div>
    </div>
  </div>
</div>

<!-- PDF.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script>
/* =========================
   Globals & utilities
========================= */
const API_EDIT="/api/edit";
const $=id=>document.getElementById(id);
const setStat=(t,cls="")=>{const el=$('stat');el.textContent=t;el.className="status "+cls;}
const setMeta=()=>$('meta').textContent=`Page ${pageNum} | scale ${scale.toFixed(2)}`
const setQueued=()=>$('queued').textContent=items.length+" items queued"
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const med=a=>{const s=a.slice().sort((x,y)=>x-y);return s.length?s[Math.floor(s.length/2)]:0;}
const mode=(arr)=>{const m=new Map(); for(const v of arr){m.set(v,(m.get(v)||0)+1)} let best=null,c=0; for(const [k,v] of m){if(v>c){c=v;best=k}} return best;}
function hexToRgb01(hex){const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);if(!m)return[0,0,0];return[parseInt(m[1],16)/255,parseInt(m[2],16)/255,parseInt(m[3],16)/255]}

// ---- OCR helpers ----
const TESS_URL='https://cdn.jsdelivr.net/npm/tesseract.js@5.0.3/dist/tesseract.min.js';
let _tessLoaded=false;
async function ensureTesseract(){
  if(_tessLoaded) return;
  await new Promise((res,rej)=>{
    const s=document.createElement('script');
    s.src=TESS_URL; s.async=true;
    s.onload=()=>res(); s.onerror=()=>rej(new Error('Failed to load Tesseract'));
    document.head.appendChild(s);
  });
  _tessLoaded=true;
}

async function ocrAreaPx(selPx){
  await ensureTesseract();
  const cv=$('cv');
  const x0=Math.max(0,Math.floor(selPx.x));
  const y0=Math.max(0,Math.floor(selPx.y));
  const w =Math.max(1,Math.floor(selPx.w));
  const h =Math.max(1,Math.floor(selPx.h));

  const off=document.createElement('canvas');
  off.width=w; off.height=h;
  const octx=off.getContext('2d');
  octx.drawImage(cv, x0, y0, w, h, 0, 0, w, h);

  const { data } = await window.Tesseract.recognize(off.toDataURL('image/png'), 'eng');
  const words = data?.words || [];

  return words
    .filter(wd => (wd.text||'').trim().length)
    .map(wd=>{
      const bx0 = wd.bbox.x0 + x0;
      const by0 = wd.bbox.y0 + y0;
      const bw  = wd.bbox.x1 - wd.bbox.x0;
      const bh  = wd.bbox.y1 - wd.bbox.y0;
      const colorHex = sampleColorMedianAtPx(bx0 + bw*0.5, by0 + bh*0.7);
      return {
        str: wd.text,
        x: bx0, y: by0,
        w: bw,  h: bh,
        sizePx: Math.max(8, bh),
        fontName: 'Times-Roman',
        colorHex,
        fauxBold: 0,
        skewDeg: 0
      };
    });
}

/* =========================
   State
========================= */
let pdfDoc=null,pageNum=1,pageCount=1,scale=1.10;
let baseViewport=null,viewport=null;
let ptPerPx=1, pxPerPt=1, pageHeightPts=0;
let fileB64=null,lastClickPtPx=null;

let items=[];         // stored in POINTS (top-left)
let groups=[];        // group frames stored in POINTS (top-left)
let selectedId=null;
let areaMode=false,eyedropMode=false;

const pdfjsLib=window['pdfjs-dist/build/pdf'];
pdfjsLib.GlobalWorkerOptions.workerSrc='https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

/* =========================
   Load / Reset
========================= */
$('load').onclick=async()=>{
  try{
    const f=$('file').files[0]; if(!f){setStat("Choose a PDF."); return;}
    fileB64=await fileToBase64(f);
    const buf=await f.arrayBuffer();
    pdfDoc=await pdfjsLib.getDocument({data:buf}).promise;
    pageCount=pdfDoc.numPages; pageNum=1;
    $('tools').style.display='';
    const sel=$('pageSelect'); sel.innerHTML="";
    for(let i=1;i<=pageCount;i++){const o=document.createElement('option');o.value=String(i);o.textContent=String(i);sel.appendChild(o);}
    sel.value="1";
    await renderPage();
    redraw();
    setStat(`Loaded ${pageCount} page(s).`,"ok");
  }catch(e){console.error(e);setStat("Error: "+e.message,"err")}
};
$('reset').onclick=()=>{
  pdfDoc=null; fileB64=null; items=[]; groups=[]; selectedId=null; $('tools').style.display='none';
  const cv=$('cv'); cv.getContext('2d').clearRect(0,0,cv.width,cv.height);
  $('overlay').innerHTML=""; $('pageWrap').style.display='none';
  setQueued(); setStat("Cleared.");
};

$('prev').onclick=async()=>{if(!pdfDoc)return; pageNum=Math.max(1,pageNum-1); $('pageSelect').value=String(pageNum); await renderPage(); redraw();};
$('next').onclick=async()=>{if(!pdfDoc)return; pageNum=Math.min(pageCount,pageNum+1); $('pageSelect').value=String(pageNum); await renderPage(); redraw();};
$('zoom').oninput=async e=>{if(!pdfDoc)return; scale=Number(e.target.value)/100; await renderPage(); redraw();};
$('pageSelect').onchange=async e=>{pageNum=Number(e.target.value)||1; await renderPage(); redraw();};
$('toggleGuides').onchange=(e)=>{ if(e.target.checked)document.body.classList.remove('noguides'); else document.body.classList.add('noguides'); };

/* =========================
   Page render & coordinates
========================= */
async function renderPage(){
  const page=await pdfDoc.getPage(pageNum);
  viewport=page.getViewport({scale});
  baseViewport=page.getViewport({scale:1});
  const cv=$('cv'), ctx=cv.getContext('2d', { willReadFrequently:true });
  cv.width=viewport.width; cv.height=viewport.height;
  ptPerPx=baseViewport.width/viewport.width;
  pxPerPt=1/ptPerPx;
  pageHeightPts = baseViewport.height;
  await page.render({canvasContext:ctx, viewport}).promise;
  $('pageWrap').style.display='';
  setMeta();
  cv.onpointermove=(e)=>{const r=cv.getBoundingClientRect(); const x=Math.round((e.clientX-r.left)), y=Math.round((e.clientY-r.top)); $('coords').textContent=`x: ${x}  y: ${y}`;}
}

/* =========================
   Helpers
========================= */
async function fileToBase64(file){
  return new Promise((resolve,reject)=>{
    const fr=new FileReader();
    fr.onload=()=>{const s=String(fr.result||"");resolve(s.includes(",")?s.split(",")[1]:s)};
    fr.onerror=reject; fr.readAsDataURL(file);
  });
}
function guessFontFromName(name){
  const fname=(name||'').toString();
  const isHelv=/helv/i.test(fname),isCour=/cour/i.test(fname);
  const isTimes=/times|newroman|tnr|minion|garamond|serif/i.test(fname)||(!isHelv&&!isCour);
  const isBold=/bold|bd|semibold|demi|medium/i.test(fname);
  const isItal=/ital|oblique|it|obl/i.test(fname);
  const isBoldItal=/bolditalic|boldoblique/i.test(fname);

  if(isHelv){
    if(isBoldItal) return 'Helvetica-BoldOblique';
    return isBold && isItal ? 'Helvetica-BoldOblique'
         : isBold ? 'Helvetica-Bold'
         : isItal ? 'Helvetica-Oblique'
         : 'Helvetica';
  }
  if(isCour){
    if(isBoldItal) return 'Courier-BoldOblique';
    return isBold && isItal ? 'Courier-BoldOblique'
         : isBold ? 'Courier-Bold'
         : isItal ? 'Courier-Oblique'
         : 'Courier';
  }
  if(isBoldItal) return 'Times-BoldItalic';
  return isBold && isItal ? 'Times-BoldItalic'
       : isBold ? 'Times-Bold'
       : isItal ? 'Times-Italic'
       : 'Times-Roman';
}

function sampleColorMedianAtPx(pxX, pxY){
  const cv = $('cv');
  const ctx = cv.getContext('2d', { willReadFrequently: true });
  const toHex = v => Math.round(v).toString(16).padStart(2,'0');

  // sample 9x9 window, keep darkest 15% to get pure text color
  const rad = 4;
  const x0 = Math.max(0, Math.round(pxX) - rad);
  const y0 = Math.max(0, Math.round(pxY) - rad);
  const w  = Math.min(rad*2+1, cv.width  - x0);
  const h  = Math.min(rad*2+1, cv.height - y0);
  if (w <= 0 || h <= 0) return '#000000';

  const data = ctx.getImageData(x0, y0, w, h).data;
  const pixels = [];
  for (let i=0;i<data.length;i+=4){
    const r=data[i], g=data[i+1], b=data[i+2], a=data[i+3];
    if (a < 128) continue; // skip transparent pixels
    const lum = 0.2126*r + 0.7152*g + 0.0722*b;
    if (lum > 240) continue; // skip near-white (background)
    pixels.push({lum, r, g, b});
  }
  
  if (!pixels.length) return '#000000';
  
  pixels.sort((a,b)=>a.lum-b.lum);
  const keep = Math.max(1, Math.floor(pixels.length*0.20));
  const darkest = pixels.slice(0, keep);

  const Rs = darkest.map(p=>p.r).sort((a,b)=>a-b);
  const Gs = darkest.map(p=>p.g).sort((a,b)=>a-b);
  const Bs = darkest.map(p=>p.b).sort((a,b)=>a-b);
  const mid = Math.floor(keep/2);
  return '#'+toHex(Rs[mid])+toHex(Gs[mid])+toHex(Bs[mid]);
}

/* =========================
   Text extraction (CANVAS PX) + style
========================= */
async function getPageTextItemsPx(){
  const page = await pdfDoc.getPage(pageNum);
  let tc;
  try {
    tc = await page.getTextContent({
      includeMarkedContent: true,
      disableCombineTextItems: true
    });
  } catch (err) {
    console.warn('⚠️ pdf.js text extraction failed, falling back to vector OCR.', err);
    tc = { items: [] };
  }

  const ctx = $('cv').getContext('2d', { willReadFrequently: true });
  const vp  = viewport; // current rendered viewport

  // 🧠 OCR fallback if text layer is empty or incomplete
if (!tc.items || tc.items.length < 10) {
  console.warn('Text layer sparse — sending to OCR fallback...');
  try {
    const cv = $('cv');
    const imgData = cv.toDataURL('image/png');
    const resp = await fetch('/api/ocr', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ image: imgData, page: pageNum })
    });
    if (resp.ok) {
      const data = await resp.json();
      if (data && Array.isArray(data.items) && data.items.length) {
        tc.items = data.items;
        console.info(`✅ OCR recovered ${data.items.length} text elements`);
      }
    } else {
      console.warn('⚠️ OCR request failed:', await resp.text());
    }
  } catch (err) {
    console.error('OCR fallback error:', err);
  }
}

  // Fallback when PDF.js finds almost nothing
  if (!tc.items || tc.items.length < 3) {
    console.warn('⚠️ Low text density detected. Running vectorTextFallback...');
    const vec = await vectorTextFallback(page, vp, ctx);
    if (vec && vec.length) {
      tc.items = tc.items.concat(vec);
      console.info(`✅ Recovered ${vec.length} vector-text segments.`);
    }
  }

  return tc.items.map(it => {
    // Map text matrix -> viewport (canvas px)
    const m = pdfjsLib.Util.transform(vp.transform, it.transform); // [a,b,c,d,e,f]
    const sizePx = Math.hypot(m[2], m[3]);        // font height in px
    const x      = m[4];                          // left (px)
    const yBase  = m[5];                          // baseline (px)
    const y      = yBase - sizePx;                // approx top (px)
    const w      = it.width * vp.scale;           // width (px)
    const h      = sizePx * 1.2;                  // generous box (px)

    // Color sample using the robust median function
    let colorHex = '#000000';
    try {
      const sampleX = x + w*0.3;
      const sampleY = y + h*0.5;
      colorHex = sampleColorMedianAtPx(sampleX, sampleY);
      console.log(`Color sampled: ${colorHex} for "${it.str}"`);
    } catch {}

    const fontName = it.fontName || 'Times-Roman';
    
    // Check transform matrix for skew (italic detection)
    const hasSkew = Math.abs(m[2]) > 0.05;
    
    // Pixel-based bold detection - sample the actual rendered glyph
    let isBoldByPixels = false;
    try {
      // Sample at the middle of the text, slightly below baseline
      const sampleX = Math.round(x + w * 0.3);
      const sampleY = Math.round(yBase - sizePx * 0.3); // yBase is baseline
      
      // Count dark pixels in a small horizontal line (measures stroke width)
      let darkCount = 0;
      const sampleWidth = Math.min(8, Math.ceil(sizePx * 0.6));
      for (let dx = 0; dx < sampleWidth; dx++) {
        const px = sampleX + dx;
        const py = sampleY;
        if (px < 0 || py < 0 || px >= cv.width || py >= cv.height) continue;
        const d = ctx.getImageData(px, py, 1, 1).data;
        const lum = 0.2126*d[0] + 0.7152*d[1] + 0.0722*d[2];
        if (lum < 100) darkCount++;
      }
      
      const darkRatio = darkCount / sampleWidth;
      isBoldByPixels = darkRatio > 0.35; // >35% dark = bold stroke
      
      if (it.str.includes('Takeaway')) {
        console.log('DEBUG Takeaway pixel:', {darkCount, sampleWidth, darkRatio, threshold: 0.35, isBold: isBoldByPixels, x: sampleX, y: sampleY});
      }
    } catch (e) {
      console.error('Bold detection error:', e);
    }
    
    const fauxBold = isBoldByPixels ? 1 : 0;
    const skewDeg  = hasSkew ? 15 : 0;

    return { str: it.str, x, y, w, h, sizePx, fontName, colorHex, fauxBold, skewDeg };
  });
}

/* =========================
   Line / column / block building
========================= */
function buildLinesPx(itemsPx){
  const items=itemsPx.slice().sort((a,b)=> (a.y-b.y) || (a.x-b.x));
  const sizes=items.map(s=>s.sizePx).sort((a,b)=>a-b);
  const medSize=sizes[Math.floor(sizes.length/2)]||12;
  const vTol=Math.max(medSize * 0.35, 3);

  const lines=[];
  for(const s of items){
    let ln=lines.find(L=>Math.abs(L.baseline - (s.y + s.h*0.85))<=vTol);
    if(!ln){
      ln={ baseline:s.y + s.h*0.85, segs:[s] };
      lines.push(ln);
    }else{
      ln.segs.push(s);
    }
  }

  for(const L of lines){
    L.segs.sort((a,b)=>a.x-b.x);
    // merge text with inferred spaces
    let text='', prev=null, left=Infinity, right=-Infinity, top=Infinity, bottom=-Infinity, sizes=[], fonts=[], colors=[], bolds=[], ital=[];
    for(const s of L.segs){
      if(prev){
        const gap=s.x-(prev.x+prev.w);
        const spaceThreshold = Math.max(s.sizePx*0.2, 2);
        if(gap > spaceThreshold) text+=' ';
      }
      text+=s.str;
      prev=s;
      left=Math.min(left,s.x); right=Math.max(right,s.x+s.w);
      top=Math.min(top,s.y); bottom=Math.max(bottom,s.y+s.h);
      sizes.push(s.sizePx); fonts.push(guessFontFromName(s.fontName)); colors.push(s.colorHex); bolds.push(s.fauxBold); ital.push(s.skewDeg?12:0);
    }
    L.text=text.trimEnd();
    
    // Calculate ACTUAL width needed to render the text (not just segment bounds)
    const avgCharWidth = L.segs.length > 0 ? (right - left) / text.replace(/\s/g,'').length : 10;
    const estimatedWidth = text.length * avgCharWidth * 0.6; // estimate with spacing
    const visualWidth = Math.max(right - left, estimatedWidth);
    
    L.xMin=left; L.xMax=left + visualWidth; L.top=top; L.bottom=bottom;
    L.sizePx=Math.round(med(sizes)); 
    L.font=mode(fonts)||'Times-Roman'; 
    L.colorHex=mode(colors.filter(c=>c!=='#ffffff'))||'#000000';
    const boldCount = bolds.filter(x=>x>=1).length;
    const italCount = ital.filter(x=>x>=6).length;
    
    // Use majority vote for line-level styling
    const avgBold = bolds.reduce((a,b)=>a+b, 0) / bolds.length;
    const avgItalic = ital.reduce((a,b)=>a+b, 0) / ital.length;
    
    L.fauxBold = avgBold >= 0.5 ? 1 : 0; 
    L.skewDeg = avgItalic >= 6 ? 15 : 0;
    console.log(`Line: "${L.text.substring(0,30)}" | Color: ${L.colorHex} | Bold: ${L.fauxBold} | Italic: ${L.skewDeg} | Font: ${L.font}`);
  }
  // sort top-to-bottom
  lines.sort((a,b)=> (a.top-b.top) || (a.xMin-b.xMin));
  return lines;
}

function buildColumns(lines){
  if(!lines.length) return [];
  const lefts=lines.map(L=>L.xMin).sort((a,b)=>a-b);
  const leftGaps=lefts.slice(1).map((v,i)=>v-lefts[i]);
  const colGap=Math.max(50, (leftGaps.length?med(leftGaps):20) * 3.5);

  const cols=[];
  for(const L of lines){
    let col=cols.find(c=>Math.abs(c.x - L.xMin)<=colGap);
    if(!col){ col={x:L.xMin, lines:[]}; cols.push(col); }
    col.lines.push(L);
  }
  cols.forEach(c=>c.lines.sort((a,b)=>a.top-b.top));
  return cols;
}

function buildBlocks(cols){
  const blocks=[];
  for(const col of cols){
    let cur=null;
    for(const L of col.lines){
      const vGap = cur ? (L.top - cur.lastBottom) : Infinity;
      const maxGap = Math.max(L.sizePx * 1.8, 12);
      const sameStyle = cur && Math.abs(L.sizePx-cur.sizePx)<=Math.max(2,cur.sizePx*0.2) && L.font===cur.font;
      if(!cur || vGap > maxGap || !sameStyle){
        cur={
          lines:[], left:L.xMin, right:L.xMax, top:L.top, bottom:L.bottom,
          sizePx:L.sizePx, font:L.font, colorHex:L.colorHex, fauxBold:L.fauxBold, skewDeg:L.skewDeg,
          sizes:[L.sizePx], fonts:[L.font], colors:[L.colorHex], bolds:[L.fauxBold], ital:[L.skewDeg?12:0],
          lastBottom:L.bottom
        };
        blocks.push(cur);
      }
      cur.lines.push(L);
      cur.left=Math.min(cur.left,L.xMin); cur.right=Math.max(cur.right,L.xMax);
      cur.top=Math.min(cur.top,L.top); cur.bottom=Math.max(cur.bottom,L.bottom);
      cur.lastBottom=L.bottom;
      cur.sizes.push(L.sizePx); cur.fonts.push(L.font); cur.colors.push(L.colorHex); cur.bolds.push(L.fauxBold); cur.ital.push(L.skewDeg?12:0);
    }
  }
  // DON'T merge styles - keep per-line styling
  return blocks;
}

/* =========================
   Overlay rendering
========================= */
function redraw(){
  const ov=$('overlay'); ov.innerHTML="";
  drawGroups(ov);
  drawItems(ov);
  setQueued();
}
function drawItems(ov){
  const pageItems=items.filter(it=>it.page===pageNum);
  for(const it of pageItems){
    const div=document.createElement('div');
    div.className='block';
    div.dataset.id=it.id;

    const leftPx=it._tempX? it._tempX*pxPerPt : it.x*pxPerPt;
    const topPx =it._tempY? it._tempY*pxPerPt : it.y*pxPerPt;
    div.style.left=leftPx+'px';

    if(it.type==='text'){
      div.style.top=topPx+'px';
      div.style.width=(it.width*pxPerPt)+'px';
      div.style.fontFamily=it.font;
      div.style.fontSize=(it.size*pxPerPt)+'px';
      div.style.color=it.colorHex||'#000000';
      div.style.lineHeight=((it.lineHeight||Math.round(it.size*1.35))*pxPerPt)+'px';
      div.textContent=it.text;
    }else{
      const pxH=Math.max(1,(it.thick||1)*pxPerPt);
      div.style.top=(topPx - pxH/2)+'px';
      div.style.width=(it.width*pxPerPt)+'px';
      div.style.height=pxH+'px';
      div.style.background=it.colorHex||'#000000';
      div.textContent='';
    }

    if(!isGroup(selectedId) && it.id===selectedId) div.classList.add('selected');

    const close=document.createElement('div'); close.className='close' + ((selectedId===it.id)?'':' hidden'); close.textContent='×';
    close.title='Delete'; close.onclick=(ev)=>{ev.stopPropagation(); items=items.filter(x=>x.id!==it.id); groups.forEach(g=>g.children=g.children.filter(ch=>ch.refId!==it.id)); if(selectedId===it.id)selectedId=null; redraw(); setQueued();};
    div.appendChild(close);

    const handle=document.createElement('div'); handle.className='handle'; div.appendChild(handle);

    // select
    div.addEventListener('pointerdown',ev=>{
      ev.preventDefault();
      if(ev.target!==handle && ev.target!==close) setSelected(it.id);
    }, {passive:false});

    // drag
    div.addEventListener('pointerdown',ev=>{
      if(ev.target===handle || ev.target===close) return;
      ev.preventDefault();
      setSelected(it.id);
      div.classList.add('dragging');
      const startX=ev.clientX,startY=ev.clientY;
      const startXPx=leftPx, startYPx= (it.type==='text')?topPx:(topPx);
      let dx=0,dy=0,anim=false;
      const move=e=>{dx=e.clientX-startX;dy=e.clientY-startY;if(!anim){anim=true;requestAnimationFrame(()=>{div.style.transform=`translate3d(${dx}px,${dy}px,0)`;anim=false;});}
        it._tempX = it.x + dx*ptPerPx; it._tempY = it.y + dy*ptPerPx;
      };
      const up=()=>{document.removeEventListener('pointermove',move);document.removeEventListener('pointerup',up);
        div.style.transform='translate3d(0,0,0)'; div.classList.remove('dragging');
        it.x = Math.round((startXPx+dx)*ptPerPx);
        it.y = Math.round((startYPx+dy)*ptPerPx);
        delete it._tempX; delete it._tempY;
        redraw();
      };
      document.addEventListener('pointermove',move,{passive:false});
      document.addEventListener('pointerup',up,{once:true});
    }, {passive:false});

    // width resize
    handle.addEventListener('pointerdown',ev=>{
      ev.stopPropagation(); ev.preventDefault();
      setSelected(it.id);
      const startX=ev.clientX,startW=parseFloat(div.style.width);
      const move=e=>{const dw=e.clientX-startX;div.style.width=Math.max(20,startW+dw)+'px';};
      const up=()=>{document.removeEventListener('pointermove',move);document.removeEventListener('pointerup',up); it.width=Math.round(parseFloat(div.style.width)*ptPerPx); redraw();};
      document.addEventListener('pointermove',move,{passive:false});
      document.addEventListener('pointerup',up,{once:true});
    });

    ov.appendChild(div);
  }
  ov.style.pointerEvents='none'; Array.from(ov.children).forEach(c=>c.style.pointerEvents='auto');
}
function drawGroups(ov){
  const pageGroups=groups.filter(g=>g.page===pageNum);
  for(const g of pageGroups){
    const div=document.createElement('div'); div.className='group'; div.dataset.id="g:"+g.id;
    if(isGroup(selectedId) && selectedId==="g:"+g.id) div.classList.add('selected');
    div.style.left=((g._tempX??g.x)*pxPerPt)+'px'; div.style.top=((g._tempY??g.y)*pxPerPt)+'px'; div.style.width=(g.w*pxPerPt)+'px'; div.style.height=(g.h*pxPerPt)+'px';

    const close=document.createElement('div'); close.className='g-close'; close.textContent='×';
    close.title='Remove group (keeps contents)'; close.onclick=(ev)=>{ev.stopPropagation(); groups=groups.filter(x=>x.id!==g.id); if(selectedId==="g:"+g.id)selectedId=null; redraw(); setQueued();};
    div.appendChild(close);
    ['tl','tr','bl','br'].forEach(pos=>{const h=document.createElement('div'); h.className='g-handle '+pos; div.appendChild(h);});

    // move group (px tracking, commit in pt)
    div.addEventListener('pointerdown',ev=>{
      if(ev.target.classList.contains('g-handle')||ev.target===close) return;
      ev.preventDefault(); setSelected("g:"+g.id);
      const startX=ev.clientX,startY=ev.clientY;
      g._tempX=g.x; g._tempY=g.y;
      const move=e=>{
        const dxPx=e.clientX-startX, dyPx=e.clientY-startY;
        g._tempX = g.x + dxPx*ptPerPx;
        g._tempY = g.y + dyPx*ptPerPx;
        div.style.transform=`translate3d(${dxPx}px,${dyPx}px,0)`;
      };
      const up=e=>{
        document.removeEventListener('pointermove',move); document.removeEventListener('pointerup',up);
        const dxPt = (e.clientX-startX)*ptPerPx, dyPt=(e.clientY-startY)*ptPerPx;
        g.x=Math.round(g.x+dxPt); g.y=Math.round(g.y+dyPt);
        delete g._tempX; delete g._tempY;
        div.style.transform='translate3d(0,0,0)';
        g.children.forEach(ch=>{const it=items.find(i=>i.id===ch.refId); if(it){it.x=Math.round(it.x+dxPt); it.y=Math.round(it.y+dyPt);}});
        redraw();
      };
      document.addEventListener('pointermove',move,{passive:false});
      document.addEventListener('pointerup',up,{once:true});
    }, {passive:false});

    // resize/scale group
    div.querySelectorAll('.g-handle').forEach(h=>{
      h.addEventListener('pointerdown',ev=>{
        ev.stopPropagation(); ev.preventDefault(); setSelected("g:"+g.id);
        const rect=div.getBoundingClientRect();
        const startX=ev.clientX,startY=ev.clientY;
        const startW=rect.width,startH=rect.height;
        const startGX=g.x,startGY=g.y,startGW=g.w,startGH=g.h;
        const corner=h.classList.contains('tl')?'tl':h.classList.contains('tr')?'tr':h.classList.contains('bl')?'bl':'br';
        const move=e=>{
          const dx=e.clientX-startX,dy=e.clientY-startY;
          let newW=startW,newH=startH,newX=rect.left,newY=rect.top;
          if(corner==='br'){newW=Math.max(20,startW+dx);newH=Math.max(20,startH+dy);}
          if(corner==='tr'){newW=Math.max(20,startW+dx);newH=Math.max(20,startH-dy);newY=rect.top+dy;}
          if(corner==='bl'){newW=Math.max(20,startW-dx);newH=Math.max(20,startH+dy);newX=rect.left+dx;}
          if(corner==='tl'){newW=Math.max(20,startW-dx);newH=Math.max(20,startH-dy);newX=rect.left+dx;newY=rect.top+dy;}
          div.style.left=newX+'px'; div.style.top=newY+'px'; div.style.width=newW+'px'; div.style.height=newH+'px';
        };
        const up=()=>{
          document.removeEventListener('pointermove',move); document.removeEventListener('pointerup',up);
          const rect2=div.getBoundingClientRect(); const sX=rect2.width/startW,sY=rect2.height/startH;
          const newGX=Math.round(rect2.left*ptPerPx), newGY=Math.round(rect2.top*ptPerPx);
          const dGX=newGX-startGX, dGY=newGY-startGY;
          const centerX=startGX+startGW/2, centerY=startGY+startGH/2;
          g.x=newGX; g.y=newGY; g.w=Math.round(startGW*sX); g.h=Math.round(startGH*sY);
          g.children.forEach(ch=>{
            const it=items.find(i=>i.id===ch.refId); if(!it) return;
            const relX=it.x-centerX, relY=it.y-centerY;
            it.x=Math.round(centerX+relX*sX+dGX);
            it.y=Math.round(centerY+relY*sY+dGY);
            if(it.type==='text'){
              it.width=Math.round(it.width*sX);
              it.size=Math.max(5,Math.round(it.size*((sX+sY)/2)));
              it.lineHeight=Math.max(6,Math.round((it.lineHeight||Math.round(it.size*1.35))*((sX+sY)/2)));
              it.tracking=(it.tracking||0)*((sX+sY)/2);
            }else{
              it.width=Math.round(it.width*sX);
              it.thick=Math.max(0.5,(it.thick||1)*((sX+sY)/2));
            }
          });
          redraw();
        };
        document.addEventListener('pointermove',move,{passive:false});
        document.addEventListener('pointerup',up,{once:true});
      }, {passive:false});
    });

    ov.appendChild(div);
  }
  ov.style.pointerEvents='none'; Array.from(ov.children).forEach(c=>c.style.pointerEvents='auto');
}
function isGroup(id){return typeof id==='string' && id.startsWith('g:');}
function setSelected(id){
  selectedId=id;
  if(isGroup(id)){ $('text').value=""; redraw(); return; }
  const it=items.find(x=>x.id===id); if(!it){$('text').value="";redraw();return;}
  if(it.type==='text'){
    $('text').value=it.text||""; $('font').value=it.font||'Times-Roman'; $('size').value=it.size||11; $('color').value=it.colorHex||'#000000'; $('width').value=it.width||460; $('lineHeight').value=it.lineHeight||Math.round((it.size||11)*1.35); $('fauxBold').value=it.fauxBold||0; $('skewDeg').value=it.skewDeg||0; $('tracking').value=it.tracking||0;
  }else{
    $('text').value=""; $('color').value=it.colorHex||'#000000'; $('lineWidth').value=it.width||460; $('lineThick').value=it.thick||2;
  }
  redraw();
}
function updateSelectedFromSidebar(){
  if(isGroup(selectedId)) return;
  const it=items.find(x=>x.id===selectedId); if(!it) return;
  if(it.type==='text'){
    it.text=$('text').value||""; it.font=$('font').value||"Times-Roman"; it.size=parseFloat($('size').value)||11; it.colorHex=$('color').value||"#000000"; it.width=parseFloat($('width').value)||460; it.lineHeight=parseFloat($('lineHeight').value)||Math.round(it.size*1.35); it.fauxBold=parseInt($('fauxBold').value)||0; it.skewDeg=parseFloat($('skewDeg').value)||0; it.tracking=parseFloat($('tracking').value)||0;
  }else{
    it.colorHex=$('color').value||it.colorHex||"#000000"; it.width=parseFloat($('lineWidth').value)||it.width||460; it.thick=parseFloat($('lineThick').value)||it.thick||2;
  }
  redraw();
}
;['text','font','size','color','width','lineHeight','fauxBold','skewDeg','tracking','lineWidth','lineThick'].forEach(id=>{
  $(id).addEventListener(id==='text'?'input':'change', updateSelectedFromSidebar);
});
window.addEventListener('keydown',(e)=>{
  if(!selectedId) return;
  if(e.key==='Delete'||e.key==='Backspace'){
    if(isGroup(selectedId)){const gid=selectedId.slice(2); groups=groups.filter(g=>g.id!==gid);}
    else{items=items.filter(x=>x.id!==selectedId); groups.forEach(g=>g.children=g.children.filter(ch=>ch.refId!==selectedId));}
    selectedId=null; redraw(); setQueued(); setStat("Deleted.","ok"); e.preventDefault();
  }
});

/* =========================
   Canvas interactions
========================= */
$('eyedrop').onclick=()=>{eyedropMode=!eyedropMode; areaMode=false; $('eyedrop').textContent=eyedropMode?"Eyedrop (ON)":"Eyedrop"; $('areaClone').textContent="Select Area (Clone)"; $('picked').textContent='picked: —'; setStat(eyedropMode?"Click near text to pick style.":"Eyedrop off.","ok");};
$('areaClone').onclick=()=>{areaMode=!areaMode; eyedropMode=false; $('areaClone').textContent=areaMode?"Select Area (ON)":"Select Area (Clone)"; $('eyedrop').textContent="Eyedrop"; setStat(areaMode?"Drag a rectangle to clone just that area.":"Area clone off.","ok");};
$('ungroup').onclick=()=>{ if(!isGroup(selectedId)){setStat("Select a section (group) first.","err");return;} const gid=selectedId.slice(2); groups=groups.filter(g=>g.id!==gid); selectedId=null; redraw(); setQueued(); setStat("Ungrouped.","ok"); };

$('cv').addEventListener('pointerdown', async (e)=>{
  const r=$('cv').getBoundingClientRect();
  const pxX=e.clientX-r.left, pxY=e.clientY-r.top;

  if(eyedropMode){
    const itemsPx=await getPageTextItemsPx();
    let best=null,bestD=1e15;
    for(const it of itemsPx){
      const cx=it.x + it.w/2, cy=it.y + it.sizePx*0.6;
      const dx=cx-pxX, dy=cy-pxY; const dd=dx*dx+dy*dy;
      if(dd<bestD){bestD=dd; best={sizePx:it.sizePx, font:guessFontFromName(it.fontName), px:[cx, cy], colorHex:it.colorHex};}
    }
    if(best){
      $('size').value=Math.max(6,Math.round(best.sizePx*ptPerPx));
      $('font').value=best.font;
      $('color').value=best.colorHex;
      $('picked').textContent=`picked: ${best.font}, ${$('size').value}pt, ${best.colorHex}`;
      setStat("Style picked.","ok");
    }
    eyedropMode=false; $('eyedrop').textContent="Eyedrop"; return;
  }

  if(areaMode){ startMarquee(pxX,pxY); return; }
  lastClickPtPx={x:pxX,y:pxY};
  setStat(`Placement set at (${Math.round(pxX)}, ${Math.round(pxY)}).`,"ok");
});

/* =========================
   Marquee selection
========================= */
let marqueeEl=null,mStart=null;
function startMarquee(pxX,pxY){
  const ov=$('overlay');
  if(marqueeEl && marqueeEl.parentNode) marqueeEl.parentNode.removeChild(marqueeEl);
  marqueeEl=document.createElement('div'); marqueeEl.className='marquee';
  marqueeEl.style.left=pxX+'px'; marqueeEl.style.top=pxY+'px'; marqueeEl.style.width='0px'; marqueeEl.style.height='0px'; ov.appendChild(marqueeEl);
  mStart={x:pxX,y:pxY};
  const move=(e)=>{const r=$('cv').getBoundingClientRect(); const cx=e.clientX-r.left, cy=e.clientY-r.top; const x=Math.min(mStart.x,cx), y=Math.min(mStart.y,cy); marqueeEl.style.left=x+'px'; marqueeEl.style.top=y+'px'; marqueeEl.style.width=Math.abs(cx-mStart.x)+'px'; marqueeEl.style.height=Math.abs(cy-mStart.y)+'px';};
  const up=async ()=>{
    document.removeEventListener('pointermove',move); document.removeEventListener('pointerup',up);
    const rect=marqueeEl.getBoundingClientRect(), cvRect=$('cv').getBoundingClientRect();
    const selPx={x:rect.left-cvRect.left,y:rect.top-cvRect.top,w:rect.width,h:rect.height};
    if(selPx.w<5 || selPx.h<5){setStat("Selection too small.","err"); marqueeEl.remove(); marqueeEl=null; return;}
    await cloneFromAreaPx(selPx, $('detectRules').checked);
    marqueeEl.remove(); marqueeEl=null;
  };
  document.addEventListener('pointermove',move,{passive:false});
  document.addEventListener('pointerup',up,{once:true});
}

/* =========================
   Area clone (PX pipeline)
========================= */
async function cloneFromAreaPx(selPx, includeRules){
  const itemsPx=await getPageTextItemsPx();
  const sx1=selPx.x, sy1=selPx.y, sx2=sx1+selPx.w, sy2=sy1+selPx.h;

  // strict containment (±1px tolerance)
  let hits=itemsPx.filter(s=>{
    const ix1=s.x, iy1=s.y, ix2=s.x+s.w, iy2=s.y+s.h;
    return !(ix2 < sx1 - 2 || ix1 > sx2 + 2 || iy2 < sy1 - 2 || iy1 > sy2 + 2);
  });
  // 🧠 If no text detected, run OCR fallback
if (!hits.length || hits.length < 3) {
  setStat("No embedded text — running OCR fallback…","ok");
  try {
    const ocrItems = await ocrAreaPx(selPx);
    if (ocrItems && ocrItems.length) {
      hits = ocrItems;
      setStat(`OCR recovered ${hits.length} text spans.`,"ok");
    } else {
      setStat("OCR found no readable text.","err");
      return;
    }
  } catch (err) {
    console.error("OCR error:", err);
    setStat("OCR failed: " + err.message, "err");
    return;
  }
}

  // lines -> columns -> blocks
  const lines=buildLinesPx(hits);
  const cols=buildColumns(lines);
  const blocks=buildBlocks(cols);
  console.log('📊 Detection:', {lines: lines.length, blocks: blocks.length, sample: blocks[0]?.lines.length});

  // optional: detect horizontal rules within selection
  const ruleLinesPx = includeRules ? detectHorizontalRulesPx(selPx) : [];

  const newIds=[];
  // push text blocks - group similar lines, split on style changes
  for(const b of blocks){
    let currentGroup = [];
    let lastStyle = null;

    for(let i=0; i<b.lines.length; i++){
      const L = b.lines[i];
      const style = `${L.font}|${Math.round(L.sizePx)}|${L.colorHex}|${L.fauxBold}|${L.skewDeg}`;
      
      // if style changed or big gap, create new item
      const prevLine = i > 0 ? b.lines[i-1] : null;
      const gap = prevLine ? (L.top - prevLine.bottom) : 0;
      const isStyleChange = lastStyle && style !== lastStyle;
      const isBigGap = gap > L.sizePx * 1.2;
      
      if (isStyleChange || isBigGap) {
        // flush current group
        if (currentGroup.length) {
          const id = crypto.randomUUID?crypto.randomUUID():String(Date.now()+Math.random());
          const firstL = currentGroup[0];
          const xPx = Math.round(Math.min(...currentGroup.map(l=>l.xMin)));
          const yPx = Math.round(firstL.top);
          const text = currentGroup.map(l=>l.text).join('\n');
          
          // WIDTH FIX: estimate based on longest line
          const longestLine = currentGroup.reduce((max, l) => l.text.length > max.text.length ? l : max, currentGroup[0]);
          const charCount = longestLine.text.length;
          const avgCharW = firstL.sizePx * 0.55;
          const estimatedW = charCount * avgCharW;
          const measuredW = Math.max(...currentGroup.map(l=>l.xMax)) - xPx;
          const wPx = Math.max(measuredW, estimatedW) * 1.15;
          const lineHeightPx = Math.round(firstL.sizePx * 1.35);

          items.push({
            id, type:'text', page:pageNum,
            x:Math.round(xPx*ptPerPx),
            y:Math.round(yPx*ptPerPx),
            width:Math.round(wPx*ptPerPx * 1.1),
            text,
            font:firstL.font,
            size:Math.round(firstL.sizePx*ptPerPx),
            colorHex:firstL.colorHex||'#000000',
            lineHeight:Math.round(lineHeightPx*ptPerPx),
            fauxBold:firstL.fauxBold||0,
            skewDeg:firstL.skewDeg||0,
            tracking:0
          });
          newIds.push(id);
        }
        currentGroup = [];
      }
      
      currentGroup.push(L);
      lastStyle = style;
    }
    
    // flush last group
    if (currentGroup.length) {
      const id = crypto.randomUUID?crypto.randomUUID():String(Date.now()+Math.random());
      const firstL = currentGroup[0];
      const xPx = Math.round(Math.min(...currentGroup.map(l=>l.xMin)));
      const yPx = Math.round(firstL.top);
      const text = currentGroup.map(l=>l.text).join('\n');
      
      // WIDTH FIX: estimate based on longest line
      const longestLine = currentGroup.reduce((max, l) => l.text.length > max.text.length ? l : max, currentGroup[0]);
      const charCount = longestLine.text.length;
      const avgCharW = firstL.sizePx * 0.55;
      const estimatedW = charCount * avgCharW;
      const measuredW = Math.max(...currentGroup.map(l=>l.xMax)) - xPx;
      const wPx = Math.max(measuredW, estimatedW) * 1.15;
      const lineHeightPx = Math.round(firstL.sizePx * 1.35);

      items.push({
        id, type:'text', page:pageNum,
        x:Math.round(xPx*ptPerPx),
        y:Math.round(yPx*ptPerPx),
        width:Math.round(wPx*ptPerPx),
        text,
        font:firstL.font,
        size:Math.round(firstL.sizePx*ptPerPx),
        colorHex:firstL.colorHex||'#000000',
        lineHeight:Math.round(lineHeightPx*ptPerPx),
        fauxBold:firstL.fauxBold||0,
        skewDeg:firstL.skewDeg||0,
        tracking:0
      });
      newIds.push(id);
    }
  }

  // push detected rules as line items
  for(const r of ruleLinesPx){
    const id=crypto.randomUUID?crypto.randomUUID():String(Date.now()+Math.random());
    items.push({
      id,type:'line',page:pageNum,
      x:Math.round(r.x*ptPerPx),
      y:Math.round(r.y*ptPerPx),
      width:Math.round(r.w*ptPerPx),
      thick:Math.max(0.5, Math.round(r.h*ptPerPx)),
      colorHex:'#000000'
    });
    newIds.push(id);
  }

  if(!newIds.length){ setStat("No content found in selection.","err"); return; }

  // group tight
  const rects=newIds.map(id=>{
    const it=items.find(i=>i.id===id);
    if(it.type==='text'){
      const linesN=(it.text.match(/\n/g)||[]).length+1;
      const h=(it.lineHeight||Math.round(it.size*1.35))*linesN;
      return {x:it.x,y:it.y,w:it.width,h};
    }else{
      return {x:it.x,y:it.y-(it.thick||1)/2,w:it.width,h:(it.thick||1)};
    }
  });
  const gx=Math.min(...rects.map(r=>r.x));
  const gy=Math.min(...rects.map(r=>r.y));
  const gxe=Math.max(...rects.map(r=>r.x+r.w));
  const gye=Math.max(...rects.map(r=>r.y+r.h));
  const gid=crypto.randomUUID?crypto.randomUUID():String(Date.now()+Math.random());
  groups.push({id:gid,page:pageNum,x:gx,y:gy,w:gxe-gx,h:gye-gy,children:newIds.map(id=>({refId:id}))});

  setSelected("g:"+gid);
  redraw(); setQueued();
  setStat(`Cloned ${newIds.length} block(s).`,"ok");
}

/* =========================
   Rule detection (PX)
========================= */
function detectHorizontalRulesPx(selPx){
  const cv=$('cv'), ctx=cv.getContext('2d',{ willReadFrequently:true });
  const x0=Math.floor(clamp(selPx.x,0,cv.width-1));
  const y0=Math.floor(clamp(selPx.y,0,cv.height-1));
  const w=Math.floor(clamp(selPx.w,1,cv.width-x0));
  const h=Math.floor(clamp(selPx.h,1,cv.height-y0));
  const img=ctx.getImageData(x0,y0,w,h);
  const {data,width,height}=img;

  const lines=[];
  for(let y=0;y<height;y++){
    let dark=0,total=0;
    for(let x=0;x<width;x++){
      const idx=(y*width+x)*4;
      const r=data[idx],g=data[idx+1],b=data[idx+2];
      const lum=0.2126*r+0.7152*g+0.0722*b;
      if(lum<60) dark++; total++;
    }
    const ratio=dark/total;
    if(ratio>0.88){
      let y2=y;
      while(y2+1<height){
        let dark2=0,tot2=0;
        for(let x=0;x<width;x++){
          const idx=((y2+1)*width+x)*4;
          const r=data[idx],g=data[idx+1],b=data[idx+2];
          const lum=0.2126*r+0.7152*g+0.0722*b; if(lum<60) dark2++; tot2++;
        }
        if(dark2/tot2>0.88){ y2++; } else break;
      }
      const thick=(y2-y)+1;
      lines.push({x:x0,y:y0+y+thick/2,w,h:thick});
      y=y2+1;
    }
  }
  return lines;
}

/* =========================
   Add text / line from sidebar
========================= */
$('addText').onclick=()=>{
  if(!fileB64){setStat("Load a PDF first.","err");return;}
  if(!lastClickPtPx){setStat("Click preview to position first.","err");return;}
  const pg=Number($('pageSelect').value)||pageNum;
  const id=crypto.randomUUID?crypto.randomUUID():String(Date.now()+Math.random());
  items.push({
    id,type:'text',page:pg,
    x:Math.round(lastClickPtPx.x*ptPerPx),y:Math.round(lastClickPtPx.y*ptPerPx),
    width:parseFloat($('width').value)||460,text:$('text').value||"",font:$('font').value||"Times-Roman",
    size:parseFloat($('size').value)||11,colorHex:$('color').value||"#000000",
    lineHeight:parseFloat($('lineHeight').value)||Math.round((parseFloat($('size').value)||11)*1.35),
    fauxBold:parseInt($('fauxBold').value)||0,skewDeg:parseFloat($('skewDeg').value)||0,tracking:parseFloat($('tracking').value)||0
  });
  setSelected(id); redraw(); setQueued(); setStat("Text added.","ok");
};
$('addLine').onclick=()=>{
  if(!fileB64){setStat("Load a PDF first.","err");return;}
  if(!lastClickPtPx){setStat("Click preview to position first.","err");return;}
  const pg=Number($('pageSelect').value)||pageNum;
  const id=crypto.randomUUID?crypto.randomUUID():String(Date.now()+Math.random());
  items.push({
    id,type:'line',page:pg,
    x:Math.round(lastClickPtPx.x*ptPerPx), y:Math.round(lastClickPtPx.y*ptPerPx),
    width:parseFloat($('lineWidth').value)||460, thick:parseFloat($('lineThick').value)||2, colorHex:$('color').value||"#000000"
  });
  setSelected(id); redraw(); setQueued(); setStat("Line added.","ok");
};

/* =========================
   Apply => /api/edit
========================= */
$('apply').onclick = async () => {
  try {
    if (!fileB64) {
      setStat("Load a PDF first.", "err");
      return;
    }
    if (items.length === 0) {
      setStat("No items queued.", "err");
      return;
    }

    setStat("Generating…");

    // get current page height in points for Y flip
    const page = await pdfDoc.getPage(pageNum);
    const pageHeightPts = baseViewport ? baseViewport.height : page.view[3];

    // flip Y axis so text renders at correct position in pdf-lib
    const edits = items.map(it => {
      const [r, g, b] = hexToRgb01(it.colorHex || '#000000');
      const yFromBottom = pageHeightPts - it.y; // convert from top origin to bottom origin

      if (it.type === 'text') {
        return {
          type: 'text',
          page: it.page,
          x: it.x,
          y: yFromBottom,
          width: it.width,
          text: it.text,
          font: it.font,
          size: it.size,
          color: [r, g, b],
          lineHeight: it.lineHeight || Math.round(it.size * 1.35),
          fauxBold: it.fauxBold || 0,
          skewDeg: it.skewDeg || 0,
          tracking: it.tracking || 0
        };
      } else {
        return {
          type: 'line',
          page: it.page,
          x: it.x,
          y: yFromBottom,
          width: it.width,
          thick: it.thick,
          color: [r, g, b]
        };
      }
    });

    // safety clamp (prevents drawing outside page)
    for (const e of edits) {
      if (e.y < 0) e.y = 0;
      if (e.y > pageHeightPts) e.y = pageHeightPts;
    }

    // send to backend
    const r = await fetch(API_EDIT, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ file: fileB64, edits })
    });

    if (!r.ok) {
      const t = await r.text();
      throw new Error(t || r.statusText);
    }

    const { pdf } = await r.json();
    const blob = new Blob(
      [Uint8Array.from(atob(pdf), c => c.charCodeAt(0))],
      { type: 'application/pdf' }
    );
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'PDF_Forge_Output.pdf';
    a.click();

    setStat("Done ✓ File downloaded.", "ok");
  } catch (e) {
    console.error(e);
    setStat("Error: " + e.message, "err");
  }
};

/* =========================
   Quick colors
========================= */
$('quickRed').onclick=()=>{$('color').value='#c62828';updateSelectedFromSidebar();};
$('quickBlue').onclick=()=>{$('color').value='#1565c0';updateSelectedFromSidebar();};
$('quickBody').onclick=()=>{$('color').value='#000000';updateSelectedFromSidebar();};
/* =========================
   Vector-based text fallback (pseudo OCR)
========================= */
async function vectorTextFallback(page, viewport, ctx) {
  try {
    const cv = $('cv');
    const { width, height } = cv;
    const data = ctx.getImageData(0, 0, width, height).data;
    const segments = [];
    const step = 12; // sampling step in pixels

    for (let y = 0; y < height; y += step) {
      for (let x = 0; x < width; x += step) {
        const i = (y * width + x) * 4;
        const r = data[i], g = data[i + 1], b = data[i + 2];
        const lum = 0.2126 * r + 0.7152 * g + 0.0722 * b;
        if (lum < 50) { // very dark pixel cluster → assume vector glyph
          segments.push({
            str: '█',
            x,
            y,
            w: step,
            h: step,
            fontName: 'Helvetica-Bold',
            colorHex: '#000000',
            fauxBold: 1,
            skewDeg: 0,
            sizePx: 10
          });
        }
      }
    }

    return segments.length ? segments : [];
  } catch (err) {
    console.error('vectorTextFallback error:', err);
    return [];
  }
}

</script>
</body>
</html>
